#![allow(unused_variables)]
use super::*;
use crate::{
    gpio::*,
    pac::{UART4, UART5, USART1, USART2, USART3},
};

macro_rules! impl_for_none_pin {
    ($Func:ident) => {
        impl<T> $Func<T> for NonePin {
            #[inline(always)]
            fn is_pin(&self) -> bool {
                false
            }
        }
    };
}

macro_rules! impl_for_none_pin_into {
    ($Func:ident) => {
        impl<T> $Func<T> for NonePin {
            type P = NonePin;
            #[inline(always)]
            fn into_alternate(self) -> Self::P {
                self
            }
            #[inline(always)]
            fn is_pin(&self) -> bool {
                false
            }
        }
    };
}

// table
// Do NOT manually modify the code.
// It's generated by scripts/generate_remap_table.py from scripts/table/stm32f1_remap_peripheral.csv

// Binder types ------------------

pub trait UartCkPin<REMAP> {
    type P;
    fn into_alternate(self) -> Self::P;
    fn is_pin(&self) -> bool {
        true
    }
}
impl_for_none_pin_into!(UartCkPin);
pub trait UartCtsPin<REMAP> {
    fn is_pin(&self) -> bool {
        true
    }
}
impl_for_none_pin!(UartCtsPin);
pub trait UartRtsPin<REMAP> {
    fn is_pin(&self) -> bool {
        true
    }
}
impl_for_none_pin!(UartRtsPin);
pub trait UartRxPin<REMAP> {
    fn is_pin(&self) -> bool {
        true
    }
}
impl_for_none_pin!(UartRxPin);
pub trait UartTxPin<REMAP> {
    type P;
    fn into_alternate(self) -> Self::P;
    fn is_pin(&self) -> bool {
        true
    }
}
impl_for_none_pin_into!(UartTxPin);

// Bind pins ---------------------

impl<UP: UpMode> UartRxPin<RemapDefault<UART4>> for PC11<Input<UP>> {}
impl UartTxPin<RemapDefault<UART4>> for PC10<Input> {
    type P = PC10<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl<UP: UpMode> UartRxPin<RemapDefault<UART5>> for PD2<Input<UP>> {}
impl UartTxPin<RemapDefault<UART5>> for PC12<Input> {
    type P = PC12<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl<UP: UpMode> UartRxPin<RemapDefault<USART1>> for PA10<Input<UP>> {}
impl UartTxPin<RemapDefault<USART1>> for PA9<Input> {
    type P = PA9<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl<UP: UpMode> UartRxPin<RemapFull<USART1>> for PB7<Input<UP>> {}
impl UartTxPin<RemapFull<USART1>> for PB6<Input> {
    type P = PB6<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl UartCkPin<RemapDefault<USART2>> for PA4<Input> {
    type P = PA4<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl<UP: UpMode> UartRxPin<RemapDefault<USART2>> for PA3<Input<UP>> {}
impl UartTxPin<RemapDefault<USART2>> for PA2<Input> {
    type P = PA2<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl UartCkPin<RemapFull<USART2>> for PD7<Input> {
    type P = PD7<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl<UP: UpMode> UartRxPin<RemapFull<USART2>> for PD6<Input<UP>> {}
impl UartTxPin<RemapFull<USART2>> for PD5<Input> {
    type P = PD5<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl UartCkPin<RemapDefault<USART3>> for PB12<Input> {
    type P = PB12<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl<UP: UpMode> UartRxPin<RemapDefault<USART3>> for PB11<Input<UP>> {}
impl UartTxPin<RemapDefault<USART3>> for PB10<Input> {
    type P = PB10<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl UartCkPin<RemapFull<USART3>> for PD10<Input> {
    type P = PD10<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl<UP: UpMode> UartRxPin<RemapFull<USART3>> for PD9<Input<UP>> {}
impl UartTxPin<RemapFull<USART3>> for PD8<Input> {
    type P = PD8<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl UartCkPin<RemapPartial1<USART3>> for PC12<Input> {
    type P = PC12<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl<UP: UpMode> UartRxPin<RemapPartial1<USART3>> for PC11<Input<UP>> {}
impl UartTxPin<RemapPartial1<USART3>> for PC10<Input> {
    type P = PC10<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}

// Register operations ------------

impl RemapMode<UART4> for RemapDefault<UART4> {
    fn remap(afio: &mut Afio) {}
}
impl RemapMode<UART5> for RemapDefault<UART5> {
    fn remap(afio: &mut Afio) {}
}
impl RemapMode<USART1> for RemapDefault<USART1> {
    fn remap(afio: &mut Afio) {
        afio.mapr.modify_mapr(|_, w| w.usart1_remap().clear_bit());
    }
}
impl RemapMode<USART1> for RemapFull<USART1> {
    fn remap(afio: &mut Afio) {
        afio.mapr.modify_mapr(|_, w| w.usart1_remap().set_bit());
    }
}
impl RemapMode<USART2> for RemapDefault<USART2> {
    fn remap(afio: &mut Afio) {
        afio.mapr.modify_mapr(|_, w| w.usart2_remap().clear_bit());
    }
}
impl RemapMode<USART2> for RemapFull<USART2> {
    fn remap(afio: &mut Afio) {
        afio.mapr.modify_mapr(|_, w| w.usart2_remap().set_bit());
    }
}
impl RemapMode<USART3> for RemapDefault<USART3> {
    fn remap(afio: &mut Afio) {
        afio.mapr
            .modify_mapr(unsafe { |_, w| w.usart3_remap().bits(0b00) });
    }
}
impl RemapMode<USART3> for RemapFull<USART3> {
    fn remap(afio: &mut Afio) {
        afio.mapr
            .modify_mapr(unsafe { |_, w| w.usart3_remap().bits(0b11) });
    }
}
impl RemapMode<USART3> for RemapPartial1<USART3> {
    fn remap(afio: &mut Afio) {
        afio.mapr
            .modify_mapr(unsafe { |_, w| w.usart3_remap().bits(0b01) });
    }
}
