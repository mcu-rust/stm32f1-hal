#![allow(unused_variables)]
use super::*;
use crate::{gpio::*, pac::*};

macro_rules! impl_for_none_pin {
    ($Func:ident) => {
        impl<T> $Func<T> for NonePin {
            #[inline(always)]
            fn is_pin(&self) -> bool {
                false
            }
        }
    };
}

macro_rules! impl_for_none_pin_into {
    ($Func:ident) => {
        impl<T> $Func<T> for NonePin {
            type P = NonePin;
            #[inline(always)]
            fn into_alternate(self) -> Self::P {
                self
            }
            #[inline(always)]
            fn is_pin(&self) -> bool {
                false
            }
        }
    };
}

// table
// Do NOT manually modify the code.
// It's generated by scripts/generate_remap_table.py from scripts/table/stm32f1_remap_peripheral.csv

// Binder types ------------------

pub trait TimBkinPin<REMAP> {
    fn is_pin(&self) -> bool {
        true
    }
}
impl_for_none_pin!(TimBkinPin);
pub trait TimCh1Pin<REMAP> {
    type P;
    fn into_alternate(self) -> Self::P;
    fn is_pin(&self) -> bool {
        true
    }
}
impl_for_none_pin_into!(TimCh1Pin);
pub trait TimCh1nPin<REMAP> {
    type P;
    fn into_alternate(self) -> Self::P;
    fn is_pin(&self) -> bool {
        true
    }
}
impl_for_none_pin_into!(TimCh1nPin);
pub trait TimCh2Pin<REMAP> {
    type P;
    fn into_alternate(self) -> Self::P;
    fn is_pin(&self) -> bool {
        true
    }
}
impl_for_none_pin_into!(TimCh2Pin);
pub trait TimCh2nPin<REMAP> {
    type P;
    fn into_alternate(self) -> Self::P;
    fn is_pin(&self) -> bool {
        true
    }
}
impl_for_none_pin_into!(TimCh2nPin);
pub trait TimCh3Pin<REMAP> {
    type P;
    fn into_alternate(self) -> Self::P;
    fn is_pin(&self) -> bool {
        true
    }
}
impl_for_none_pin_into!(TimCh3Pin);
pub trait TimCh3nPin<REMAP> {
    type P;
    fn into_alternate(self) -> Self::P;
    fn is_pin(&self) -> bool {
        true
    }
}
impl_for_none_pin_into!(TimCh3nPin);
pub trait TimCh4Pin<REMAP> {
    type P;
    fn into_alternate(self) -> Self::P;
    fn is_pin(&self) -> bool {
        true
    }
}
impl_for_none_pin_into!(TimCh4Pin);
pub trait TimEtrPin<REMAP> {
    fn is_pin(&self) -> bool {
        true
    }
}
impl_for_none_pin!(TimEtrPin);

// Bind pins ---------------------

#[cfg(any(feature = "f100", feature = "f103", feature = "connectivity"))]
impl TimCh1Pin<RemapDefault<TIM1>> for PA8<Input> {
    type P = PA8<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(any(feature = "f100", feature = "f103", feature = "connectivity"))]
impl TimCh2Pin<RemapDefault<TIM1>> for PA9<Input> {
    type P = PA9<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(any(feature = "f100", feature = "f103", feature = "connectivity"))]
impl TimCh3Pin<RemapDefault<TIM1>> for PA10<Input> {
    type P = PA10<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(any(feature = "f100", feature = "f103", feature = "connectivity"))]
impl TimCh4Pin<RemapDefault<TIM1>> for PA11<Input> {
    type P = PA11<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(any(feature = "f100", feature = "f103", feature = "connectivity"))]
impl TimCh1Pin<RemapFull<TIM1>> for PE9<Input> {
    type P = PE9<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(any(feature = "f100", feature = "f103", feature = "connectivity"))]
impl TimCh2Pin<RemapFull<TIM1>> for PE11<Input> {
    type P = PE11<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(any(feature = "f100", feature = "f103", feature = "connectivity"))]
impl TimCh3Pin<RemapFull<TIM1>> for PE13<Input> {
    type P = PE13<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(any(feature = "f100", feature = "f103", feature = "connectivity"))]
impl TimCh4Pin<RemapFull<TIM1>> for PE14<Input> {
    type P = PE14<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(any(feature = "f100", feature = "f103", feature = "connectivity"))]
impl TimCh1Pin<RemapPartial1<TIM1>> for PA8<Input> {
    type P = PA8<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(any(feature = "f100", feature = "f103", feature = "connectivity"))]
impl TimCh2Pin<RemapPartial1<TIM1>> for PA9<Input> {
    type P = PA9<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(any(feature = "f100", feature = "f103", feature = "connectivity"))]
impl TimCh3Pin<RemapPartial1<TIM1>> for PA10<Input> {
    type P = PA10<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(any(feature = "f100", feature = "f103", feature = "connectivity"))]
impl TimCh4Pin<RemapPartial1<TIM1>> for PA11<Input> {
    type P = PA11<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(feature = "xl")]
impl TimCh1Pin<RemapDefault<TIM10>> for PB8<Input> {
    type P = PB8<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(feature = "xl")]
impl TimCh1Pin<RemapFull<TIM10>> for PF6<Input> {
    type P = PF6<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(feature = "xl")]
impl TimCh1Pin<RemapDefault<TIM11>> for PB9<Input> {
    type P = PB9<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(feature = "xl")]
impl TimCh1Pin<RemapFull<TIM11>> for PF7<Input> {
    type P = PF7<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(any(feature = "xl", all(feature = "f100", feature = "high",)))]
impl TimCh1Pin<RemapDefault<TIM12>> for PB14<Input> {
    type P = PB14<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(any(feature = "xl", all(feature = "f100", feature = "high",)))]
impl TimCh2Pin<RemapDefault<TIM12>> for PB15<Input> {
    type P = PB15<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(any(feature = "xl", all(feature = "f100", feature = "high",)))]
impl TimCh1Pin<RemapDefault<TIM13>> for PA6<Input> {
    type P = PA6<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(any(feature = "xl", all(feature = "f100", feature = "high",)))]
impl TimCh1Pin<RemapFull<TIM13>> for PF8<Input> {
    type P = PF8<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(any(feature = "xl", all(feature = "f100", feature = "high",)))]
impl TimCh1Pin<RemapDefault<TIM14>> for PA7<Input> {
    type P = PA7<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(any(feature = "xl", all(feature = "f100", feature = "high",)))]
impl TimCh1Pin<RemapFull<TIM14>> for PF9<Input> {
    type P = PF9<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl TimCh1Pin<RemapDefault<TIM2>> for PA0<Input> {
    type P = PA0<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl TimCh2Pin<RemapDefault<TIM2>> for PA1<Input> {
    type P = PA1<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl TimCh3Pin<RemapDefault<TIM2>> for PA2<Input> {
    type P = PA2<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl TimCh4Pin<RemapDefault<TIM2>> for PA3<Input> {
    type P = PA3<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl TimCh1Pin<RemapFull<TIM2>> for PA15<Input> {
    type P = PA15<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl TimCh2Pin<RemapFull<TIM2>> for PB3<Input> {
    type P = PB3<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl TimCh3Pin<RemapFull<TIM2>> for PB10<Input> {
    type P = PB10<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl TimCh4Pin<RemapFull<TIM2>> for PB11<Input> {
    type P = PB11<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl TimCh1Pin<RemapPartial1<TIM2>> for PA15<Input> {
    type P = PA15<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl TimCh2Pin<RemapPartial1<TIM2>> for PB3<Input> {
    type P = PB3<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl TimCh3Pin<RemapPartial1<TIM2>> for PA2<Input> {
    type P = PA2<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl TimCh4Pin<RemapPartial1<TIM2>> for PA3<Input> {
    type P = PA3<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl TimCh1Pin<RemapPartial2<TIM2>> for PA0<Input> {
    type P = PA0<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl TimCh2Pin<RemapPartial2<TIM2>> for PA1<Input> {
    type P = PA1<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl TimCh3Pin<RemapPartial2<TIM2>> for PB10<Input> {
    type P = PB10<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl TimCh4Pin<RemapPartial2<TIM2>> for PB11<Input> {
    type P = PB11<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl TimCh1Pin<RemapDefault<TIM3>> for PA6<Input> {
    type P = PA6<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl TimCh2Pin<RemapDefault<TIM3>> for PA7<Input> {
    type P = PA7<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl TimCh3Pin<RemapDefault<TIM3>> for PB0<Input> {
    type P = PB0<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl TimCh4Pin<RemapDefault<TIM3>> for PB1<Input> {
    type P = PB1<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl TimCh1Pin<RemapFull<TIM3>> for PC6<Input> {
    type P = PC6<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl TimCh2Pin<RemapFull<TIM3>> for PC7<Input> {
    type P = PC7<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl TimCh3Pin<RemapFull<TIM3>> for PC8<Input> {
    type P = PC8<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl TimCh4Pin<RemapFull<TIM3>> for PC9<Input> {
    type P = PC9<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl TimCh1Pin<RemapPartial1<TIM3>> for PB4<Input> {
    type P = PB4<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl TimCh2Pin<RemapPartial1<TIM3>> for PB5<Input> {
    type P = PB5<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl TimCh3Pin<RemapPartial1<TIM3>> for PB0<Input> {
    type P = PB0<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl TimCh4Pin<RemapPartial1<TIM3>> for PB1<Input> {
    type P = PB1<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(feature = "medium")]
impl TimCh1Pin<RemapDefault<TIM4>> for PB6<Input> {
    type P = PB6<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(feature = "medium")]
impl TimCh2Pin<RemapDefault<TIM4>> for PB7<Input> {
    type P = PB7<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(feature = "medium")]
impl TimCh3Pin<RemapDefault<TIM4>> for PB8<Input> {
    type P = PB8<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(feature = "medium")]
impl TimCh4Pin<RemapDefault<TIM4>> for PB9<Input> {
    type P = PB9<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(feature = "medium")]
impl TimCh1Pin<RemapFull<TIM4>> for PD12<Input> {
    type P = PD12<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(feature = "medium")]
impl TimCh2Pin<RemapFull<TIM4>> for PD13<Input> {
    type P = PD13<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(feature = "medium")]
impl TimCh3Pin<RemapFull<TIM4>> for PD14<Input> {
    type P = PD14<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(feature = "medium")]
impl TimCh4Pin<RemapFull<TIM4>> for PD15<Input> {
    type P = PD15<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(any(feature = "high", feature = "connectivity"))]
impl TimCh1Pin<RemapDefault<TIM5>> for PA0<Input> {
    type P = PA0<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(any(feature = "high", feature = "connectivity"))]
impl TimCh2Pin<RemapDefault<TIM5>> for PA1<Input> {
    type P = PA1<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(any(feature = "high", feature = "connectivity"))]
impl TimCh3Pin<RemapDefault<TIM5>> for PA2<Input> {
    type P = PA2<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(any(feature = "high", feature = "connectivity"))]
impl TimCh4Pin<RemapDefault<TIM5>> for PA3<Input> {
    type P = PA3<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(any(feature = "high", feature = "connectivity"))]
impl TimCh1Pin<RemapFull<TIM5>> for PA0<Input> {
    type P = PA0<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(any(feature = "high", feature = "connectivity"))]
impl TimCh2Pin<RemapFull<TIM5>> for PA1<Input> {
    type P = PA1<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(any(feature = "high", feature = "connectivity"))]
impl TimCh3Pin<RemapFull<TIM5>> for PA2<Input> {
    type P = PA2<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(all(feature = "f103", feature = "high"))]
impl TimCh1Pin<RemapDefault<TIM8>> for PC6<Input> {
    type P = PC6<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(all(feature = "f103", feature = "high"))]
impl TimCh2Pin<RemapDefault<TIM8>> for PC7<Input> {
    type P = PC7<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(all(feature = "f103", feature = "high"))]
impl TimCh3Pin<RemapDefault<TIM8>> for PC8<Input> {
    type P = PC8<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(all(feature = "f103", feature = "high"))]
impl TimCh4Pin<RemapDefault<TIM8>> for PC9<Input> {
    type P = PC9<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(feature = "xl")]
impl TimCh1Pin<RemapDefault<TIM9>> for PA2<Input> {
    type P = PA2<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(feature = "xl")]
impl TimCh2Pin<RemapDefault<TIM9>> for PA3<Input> {
    type P = PA3<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(feature = "xl")]
impl TimCh1Pin<RemapFull<TIM9>> for PE5<Input> {
    type P = PE5<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(feature = "xl")]
impl TimCh2Pin<RemapFull<TIM9>> for PE6<Input> {
    type P = PE6<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}

// Register operations ------------

#[cfg(any(feature = "f100", feature = "f103", feature = "connectivity"))]
impl RemapMode<TIM1> for RemapDefault<TIM1> {
    fn remap(afio: &mut Afio) {
        afio.mapr
            .modify_mapr(unsafe { |_, w| w.tim1_remap().bits(0b00) });
    }
}
#[cfg(any(feature = "f100", feature = "f103", feature = "connectivity"))]
impl RemapMode<TIM1> for RemapFull<TIM1> {
    fn remap(afio: &mut Afio) {
        afio.mapr
            .modify_mapr(unsafe { |_, w| w.tim1_remap().bits(0b11) });
    }
}
#[cfg(any(feature = "f100", feature = "f103", feature = "connectivity"))]
impl RemapMode<TIM1> for RemapPartial1<TIM1> {
    fn remap(afio: &mut Afio) {
        afio.mapr
            .modify_mapr(unsafe { |_, w| w.tim1_remap().bits(0b01) });
    }
}
#[cfg(feature = "xl")]
impl RemapMode<TIM10> for RemapDefault<TIM10> {
    fn remap(afio: &mut Afio) {
        afio.mapr2.modify_mapr(|_, w| w.tim10_remap().clear_bit());
    }
}
#[cfg(feature = "xl")]
impl RemapMode<TIM10> for RemapFull<TIM10> {
    fn remap(afio: &mut Afio) {
        afio.mapr2.modify_mapr(|_, w| w.tim10_remap().set_bit());
    }
}
#[cfg(feature = "xl")]
impl RemapMode<TIM11> for RemapDefault<TIM11> {
    fn remap(afio: &mut Afio) {
        afio.mapr2.modify_mapr(|_, w| w.tim11_remap().clear_bit());
    }
}
#[cfg(feature = "xl")]
impl RemapMode<TIM11> for RemapFull<TIM11> {
    fn remap(afio: &mut Afio) {
        afio.mapr2.modify_mapr(|_, w| w.tim11_remap().set_bit());
    }
}
#[cfg(any(feature = "xl", all(feature = "f100", feature = "high",)))]
impl RemapMode<TIM12> for RemapDefault<TIM12> {
    fn remap(afio: &mut Afio) {}
}
#[cfg(any(feature = "xl", all(feature = "f100", feature = "high",)))]
impl RemapMode<TIM13> for RemapDefault<TIM13> {
    fn remap(afio: &mut Afio) {
        afio.mapr2.modify_mapr(|_, w| w.tim13_remap().clear_bit());
    }
}
#[cfg(any(feature = "xl", all(feature = "f100", feature = "high",)))]
impl RemapMode<TIM13> for RemapFull<TIM13> {
    fn remap(afio: &mut Afio) {
        afio.mapr2.modify_mapr(|_, w| w.tim13_remap().set_bit());
    }
}
#[cfg(any(feature = "xl", all(feature = "f100", feature = "high",)))]
impl RemapMode<TIM14> for RemapDefault<TIM14> {
    fn remap(afio: &mut Afio) {
        afio.mapr2.modify_mapr(|_, w| w.tim14_remap().clear_bit());
    }
}
#[cfg(any(feature = "xl", all(feature = "f100", feature = "high",)))]
impl RemapMode<TIM14> for RemapFull<TIM14> {
    fn remap(afio: &mut Afio) {
        afio.mapr2.modify_mapr(|_, w| w.tim14_remap().set_bit());
    }
}
impl RemapMode<TIM2> for RemapDefault<TIM2> {
    fn remap(afio: &mut Afio) {
        afio.mapr
            .modify_mapr(unsafe { |_, w| w.tim2_remap().bits(0b00) });
    }
}
impl RemapMode<TIM2> for RemapFull<TIM2> {
    fn remap(afio: &mut Afio) {
        afio.mapr
            .modify_mapr(unsafe { |_, w| w.tim2_remap().bits(0b11) });
    }
}
impl RemapMode<TIM2> for RemapPartial1<TIM2> {
    fn remap(afio: &mut Afio) {
        afio.mapr
            .modify_mapr(unsafe { |_, w| w.tim2_remap().bits(0b01) });
    }
}
impl RemapMode<TIM2> for RemapPartial2<TIM2> {
    fn remap(afio: &mut Afio) {
        afio.mapr
            .modify_mapr(unsafe { |_, w| w.tim2_remap().bits(0b10) });
    }
}
impl RemapMode<TIM3> for RemapDefault<TIM3> {
    fn remap(afio: &mut Afio) {
        afio.mapr
            .modify_mapr(unsafe { |_, w| w.tim3_remap().bits(0b00) });
    }
}
impl RemapMode<TIM3> for RemapFull<TIM3> {
    fn remap(afio: &mut Afio) {
        afio.mapr
            .modify_mapr(unsafe { |_, w| w.tim3_remap().bits(0b11) });
    }
}
impl RemapMode<TIM3> for RemapPartial1<TIM3> {
    fn remap(afio: &mut Afio) {
        afio.mapr
            .modify_mapr(unsafe { |_, w| w.tim3_remap().bits(0b10) });
    }
}
#[cfg(feature = "medium")]
impl RemapMode<TIM4> for RemapDefault<TIM4> {
    fn remap(afio: &mut Afio) {
        afio.mapr.modify_mapr(|_, w| w.tim4_remap().clear_bit());
    }
}
#[cfg(feature = "medium")]
impl RemapMode<TIM4> for RemapFull<TIM4> {
    fn remap(afio: &mut Afio) {
        afio.mapr.modify_mapr(|_, w| w.tim4_remap().set_bit());
    }
}
#[cfg(any(feature = "high", feature = "connectivity"))]
impl RemapMode<TIM5> for RemapDefault<TIM5> {
    fn remap(afio: &mut Afio) {
        afio.mapr.modify_mapr(|_, w| w.tim5ch4_iremap().clear_bit());
    }
}
#[cfg(any(feature = "high", feature = "connectivity"))]
impl RemapMode<TIM5> for RemapFull<TIM5> {
    fn remap(afio: &mut Afio) {
        afio.mapr.modify_mapr(|_, w| w.tim5ch4_iremap().set_bit());
    }
}
#[cfg(all(feature = "f103", feature = "high"))]
impl RemapMode<TIM8> for RemapDefault<TIM8> {
    fn remap(afio: &mut Afio) {}
}
#[cfg(feature = "xl")]
impl RemapMode<TIM9> for RemapDefault<TIM9> {
    fn remap(afio: &mut Afio) {
        afio.mapr2.modify_mapr(|_, w| w.tim9_remap().clear_bit());
    }
}
#[cfg(feature = "xl")]
impl RemapMode<TIM9> for RemapFull<TIM9> {
    fn remap(afio: &mut Afio) {
        afio.mapr2.modify_mapr(|_, w| w.tim9_remap().set_bit());
    }
}
