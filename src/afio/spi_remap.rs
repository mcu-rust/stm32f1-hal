#![allow(unused_variables)]
use super::*;
use crate::{gpio::*, pac::*};
use embedded_hal::digital::OutputPin;

pub trait SpiCsPin<PIN: OutputPin> {
    fn into_cs_pin(self) -> PIN;
}

impl<const P: char, const N: u8> SpiCsPin<Pin<P, N, Output<PushPull>>> for Pin<P, N, Input>
where
    Self: HL,
{
    fn into_cs_pin(self) -> Pin<P, N, Output<PushPull>> {
        let mut cr = Self::get_cr();
        self.into_push_pull_output_with_state(&mut cr, PinState::High)
    }
}

macro_rules! impl_for_none_pin_into {
    ($Func:ident) => {
        impl<T> $Func<T> for NonePin {
            type P = NonePin;
            #[inline(always)]
            fn into_alternate(self) -> Self::P {
                self
            }
            #[inline(always)]
            fn is_pin(&self) -> bool {
                false
            }
        }
    };
}

// table
// Do NOT manually modify the code.
// It's generated by scripts/generate_remap_table.py from scripts/table/stm32f1_remap_peripheral.csv

// Binder types ------------------

pub trait SpiMisoPin<REMAP> {}
pub trait SpiMosiPin<REMAP> {
    type P;
    fn into_alternate(self) -> Self::P;
    fn is_pin(&self) -> bool {
        true
    }
}
impl_for_none_pin_into!(SpiMosiPin);
pub trait SpiNssPin<REMAP> {
    type P;
    fn into_alternate(self) -> Self::P;
}
pub trait SpiSckPin<REMAP> {
    type P;
    fn into_alternate(self) -> Self::P;
}

// Bind pins ---------------------

impl<UP: UpMode> SpiMisoPin<RemapDefault<SPI1>> for PA6<Input<UP>> {}
impl SpiMosiPin<RemapDefault<SPI1>> for PA7<Input> {
    type P = PA7<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl SpiNssPin<RemapDefault<SPI1>> for PA4<Input> {
    type P = PA4<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl SpiSckPin<RemapDefault<SPI1>> for PA5<Input> {
    type P = PA5<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl<UP: UpMode> SpiMisoPin<RemapFull<SPI1>> for PB4<Input<UP>> {}
impl SpiMosiPin<RemapFull<SPI1>> for PB5<Input> {
    type P = PB5<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl SpiNssPin<RemapFull<SPI1>> for PA15<Input> {
    type P = PA15<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl SpiSckPin<RemapFull<SPI1>> for PB3<Input> {
    type P = PB3<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl<UP: UpMode> SpiMisoPin<RemapDefault<SPI2>> for PB14<Input<UP>> {}
impl SpiMosiPin<RemapDefault<SPI2>> for PB15<Input> {
    type P = PB15<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl SpiNssPin<RemapDefault<SPI2>> for PB12<Input> {
    type P = PB12<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
impl SpiSckPin<RemapDefault<SPI2>> for PB13<Input> {
    type P = PB13<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(feature = "connectivity")]
impl<UP: UpMode> SpiMisoPin<RemapDefault<SPI3>> for PB4<Input<UP>> {}
#[cfg(feature = "connectivity")]
impl SpiMosiPin<RemapDefault<SPI3>> for PB5<Input> {
    type P = PB5<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(feature = "connectivity")]
impl SpiNssPin<RemapDefault<SPI3>> for PA15<Input> {
    type P = PA15<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(feature = "connectivity")]
impl SpiSckPin<RemapDefault<SPI3>> for PB3<Input> {
    type P = PB3<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(feature = "connectivity")]
impl<UP: UpMode> SpiMisoPin<RemapFull<SPI3>> for PC11<Input<UP>> {}
#[cfg(feature = "connectivity")]
impl SpiMosiPin<RemapFull<SPI3>> for PC12<Input> {
    type P = PC12<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(feature = "connectivity")]
impl SpiNssPin<RemapFull<SPI3>> for PA4<Input> {
    type P = PA4<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}
#[cfg(feature = "connectivity")]
impl SpiSckPin<RemapFull<SPI3>> for PC10<Input> {
    type P = PC10<Alternate<PushPull>>;
    fn into_alternate(self) -> Self::P {
        self.into_mode(&mut Cr)
    }
}

// Register operations ------------

impl RemapMode<SPI1> for RemapDefault<SPI1> {
    fn remap(afio: &mut Afio) {
        afio.mapr.modify_mapr(|_, w| w.spi1_remap().clear_bit());
    }
}
impl RemapMode<SPI1> for RemapFull<SPI1> {
    fn remap(afio: &mut Afio) {
        afio.mapr.modify_mapr(|_, w| w.spi1_remap().set_bit());
    }
}
impl RemapMode<SPI2> for RemapDefault<SPI2> {
    fn remap(afio: &mut Afio) {}
}
#[cfg(feature = "connectivity")]
impl RemapMode<SPI3> for RemapDefault<SPI3> {
    fn remap(afio: &mut Afio) {
        afio.mapr.modify_mapr(|_, w| w.spi3_remap().clear_bit());
    }
}
#[cfg(feature = "connectivity")]
impl RemapMode<SPI3> for RemapFull<SPI3> {
    fn remap(afio: &mut Afio) {
        afio.mapr.modify_mapr(|_, w| w.spi3_remap().set_bit());
    }
}
